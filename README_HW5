Jose Rodriguez 107927299
Kathryn Blecher 108871623

HW 5

This homework testing was broken down into three parts for easier grading

First can be tested with the following flags:
-fp <which part> <type of scheduling for disk> -d L
-fp is what triggers these test cases
<which part> is the part of the homework, theres three options part1, part2, part3
the debugging flag 'L' displays more information on what goes on kernel

example of usage:
	-fp part2 test -d L
	-fp part1 fifo
	-fp part1 test -d L
second argument to -fp must be there, can be anything if testing part1 or part2
PART ONE
The first part uses a file to test the functionality of heap expansion
the file testing this functionality is part1.c found within the test folder
the executable used during testing has been included. 
part1.c starts by trying to allocate something into the initial address
this causes an a trap and the bad address is resolved within the exception handler
the output can be seen in both places, the console and the nachos terminal.

The following is a snipped of the console:
4417	CPU0	system	on	[L] AddressErrorException triggered by program.
4417	CPU0	system	on	[L] Bad address that caused AddressErrorException 2944
4417	CPU0	system	on	[L] Pages needed to be extended 1
4417	CPU0	system	on	[L] Expanding vp table by 1
4418	CPU0	system	on	[L] PageFaultException triggered by program.
4418	CPU0	system	on	[L] Bad address that caused PageFAultException 2944
4418	CPU0	system	on	[L] Index of page to get physical memory for: 23
4418	CPU0	system	on	[L] Trying to give physical to 23
4418	CPU0	system	on	[L] Setting physical memory for  vmPageNum 23 on physical 23
4870	CPU0	system	on	[L] Trying to write at 1464

Some of the information displayed contains what causes the issue, the number of
pages that the virtual memory should be expanded, the bad address that caused
the exception, and the physical memory index page that is given in exchange. There
is also a display on the Write that shows where in memory the information is being written
to which can be compared to the bad address to match testing coditions.
On the Nachos console, there is display of what is happeing and how the program is tested
for example, it shows how the memory is being added to the address, how much memory is added
to the adddress and the contents being put on memory, as well as being retrieved at the end
to demosrate that it was placed correctly.
Classes modified include MemManager.java, ExceptionHandler.java, AddrSpace.java

PART TWO

            Format of a memory block
    +------------------------------------+
    |            64-bits wide            |
    +------------------------------------+

    +----------------+------------+------+    ------------
    | Requested Size | Block Size | 000a |    Header Block
    |     in bytes   |  in bytes  |      |
    |     32bits     |   28bits   | 4bits|
    +----------------+------------+------+    ------------
    |                                    |    Content of
    |         Payload and Padding        |    the payload
    |           (N Memory Rows)          |
    |                                    |
    |                                    |
    +---------------+-------------+------+    ------------
    |     Unused    | Block Size  | 000a |    Footer Block
    |               |  in bytes   |      |
    +------------------------------------+    ------------

The above drawing displays the way malloc was implemented. Contains various fields to keep track of blocks
the implementation is of an explicit free list, there's three files assoaciated with it, malloc.c, malloc.h, 
and malloc_test.c. The Makefile was modified to allow for an object to be created, running the following can
build it: make malloc_test, an executable is included that was prebuild for testing. 

NOTE: In case these fail due to make file, the contents of them can be found in mal.c and mal.h, 
these can be compiled using supplied Makefile without needing to modify it, mal.c contains the main. 

example of usage:
	-fp part2 test
	-fp part2 test -d L
When testing this file the following output is to be expected with flag L: 

6428	CPU0	system	on	[L] Setting physical memory for  vmPageNum 84 on physical 84
6460	CPU0	system	on	[L] AddressErrorException triggered by program.
6460	CPU0	system	on	[L] Bad address that caused AddressErrorException 10880
6460	CPU0	system	on	[L] Pages needed to be extended 1
6460	CPU0	system	on	[L] Expanding vp table by 1
6462	CPU0	system	on	[L] PageFaultException triggered by program.
6462	CPU0	system	on	[L] Bad address that caused PageFAultException 10880
6462	CPU0	system	on	[L] Index of page to get physical memory for: 85
6462	CPU0	system	on	[L] Trying to give physical to 85
6462	CPU0	system	on	[L] Setting physical memory for  vmPageNum 85 on physical 85
6680	CPU0	system	on	[L] AddressErrorException triggered by program.
6680	CPU0	system	on	[L] Bad address that caused AddressErrorException 11136
6680	CPU0	system	on	[L] Pages needed to be extended 2
6680	CPU0	system	on	[L] Expanding vp table by 2
6681	CPU0	system	on	[L] PageFaultException triggered by program.
6681	CPU0	system	on	[L] Bad address that caused PageFAultException 11136
6681	CPU0	system	on	[L] Index of page to get physical memory for: 87
6681	CPU0	system	on	[L] Trying to give physical to 87
6681	CPU0	system	on	[L] Setting physical memory for  vmPageNum 87 on physical 86
7541	CPU0	system	on	[L] Trying to write at 8928
10629	CPU0	system	on	[L] Trying to write at 8924
10715	CPU0	system	on	[L] Trying to write at 8920

This should be the exact same as the previous part, except with different numbers,
exception is triggered, pages are allocated, physical page is given if available.
In the Nachos console itself, there is a different output that demostrates malloc and free
the line on top of each test case shows what is being tested. Followed by the starting address
of the data (of that returned by malloc). Then data is put into that location to desmostrate
that it does have the physical area, then it prints it. Also the number of free blocks are displayed
as we free the blocks. 

PART THREE

This part we created an additional driver for the OS by adding another Disk.class. We made our
initialization of it in the Paging class. The paging in this part references the swapEntry and swapMapEntry
in which swapEntry hold the vpn and pageID and the swapMapEntry holds the swapEntry and the sector
number of the page. The swapMapEntries are then saved in an ArrayList in the Paging class for reference. The Paging
class also uses a FIFO page eviction policy in which pages are stored starting at sector 0, and 
the evictionID is initialized to 0. When a page needs to be evicted for another, it starts at 0, then
the evictionID is incremented to push out the following page when needed.