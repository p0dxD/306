Jose Rodriguez 107927299
Kathryn Blecher 108871623

Added Components HW3
1. First-come, first-served (FCFS, non-preemptive): For this mode the 
	default implemantation was left, it utilizes two FIFOQueues one for user threads
	and one for the kernel threads.
FLAG: no flag 

2. Round-robin (RR, preemptive): For this two queues are used one for the UserThreads
	and one for the Kernel threads, both are FIFOQueues. The scheduler chooses from 
	user queue if kernel queue is empty. The max quantum for initial RR is 100 with a 
	max of 1000 at which point it yields to a kernel thread as priority, or a user thread
	if there is no kernel thread. 
FLAG: -rr

3. Shortest process next (SPN, non-preemptive): This uses two queues one FIFO for kernel threads,
	one PriorityQueue which takes in a SPNComparator which sorts the processes based on burst.
	Once a process calls the PredicCPU system call the cpu is yield to reposition it back in the 
	queue at the correct location, only the user threads happen to go through this. The program
	then runs till the end once it has been positioned to the correct location without further 
	interruptions.
FLAG: -spn

4. Shortest remaining time first (SRT, preemptive upon process arrival): It uses the same queues as
	the SPN but in this case we preempt when a process arrives , we run this one or we run a kernel
	if there is a kernel thread waiting on the FIFO queue. 

FLAG: -srt

5. Highest response-ratio next (HRRN, non-preemptive): Uses same queues as the other ones and activates
	interrupts which add 100 each time to those threads already in the queue. The new value being inserted is
	calculated with (w+s)/s and inserted on the right position according to the values updated. 

FLAG: -hrrn

6. Feedback scheduling (preemptive, use 5 queues): This contains 4 FIFO and one RR queue which act on different
	policies quantum. The first queue is up to 1000, the second 2 times this, etc. till we get to the last one. 
	When an item arrives it gets inserted to the first queue, and its value of next queue insert is increased.
	If it was to be reinserted then it will be in the next queue. This happens till the queue ends up at the last one.
	The quantum is checked within the interrupt handler.

FLAG: -fbs


	The test causes the thread to sleep for the given number of ticks and creates a process when it wakes up, 
randomness is calculated using exponential randomness. This creates threads and sleeps at different intervals 
with different bursts. Testing was done in multiple CPU's as well as single CPU with 
other flags turned on. 

Note: The stack size takes majority of memory, and at most 10 programs or so can be run.

The flags to see ouput are A and if more information needs to be seen about processes
running and executing the flag S can be used.