Nachos HW1

I.Callout.java
We created a constructor that initializes the current time when the constructor is called. We also have a reference to the Timer from within the class. When the handler interrupts every 100 ticks, we increment the current time by 100. 

When the schedule method is called, we turn off the interrupt handler, then proceed to add the ticksFromNow to the current time, and wrap the future callout time into a Long wrapper class. We associate the Runnable with its start time by storing them into a HashMap, where the start time Long objects are mapped to the runnable to be executed. 

Therefore, in our interrupt handler, after we updated the current system time, we check our priority queue for the earliest timed callout. If the scheduled callout time is within the past 100 ticks of the current system time, we execute the Runnable. 


II.SynchronousQueue.java

In SynchronousQueue, we created semaphores to represent data availability and space capacity. The space capacity is set to zero, and is basically used to block producer threads from returning, if there is no consumer thread to match with it.

- The producer threads all P() on the space semaphore and consumer V() on the space semaphore. 
- The consumer threads all P() on the data semaphore and producer V() on the data semaphore. 

There is also two variables - consumers,producers, that keep track of consumer threads and producer threads respectively that are active within the queue.


Take(): Increments the consumers variable. Then blocks on availability of data, by P() on datasemaphore. If a producer thread adds an object into the queue, the take thread will wake up and return that object. 



III.SynchronousQueue.java



Debugging must be run with "C" and "Q" parameters.  "C" for the callout debugging and "Q" for the synchronous queue debugging. 